CREATE TABLE IF NOT EXISTS public.projects (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at timestamptz NOT NULL DEFAULT now(),
  name text DEFAULT 'Project'::text,
  data json,
  updated_at timestamptz,
  owner uuid
);

-- foreign key to auth.users(id)
ALTER TABLE public.projects
  ADD CONSTRAINT projects_owner_fkey FOREIGN KEY (owner) REFERENCES auth.users(id) ON DELETE SET NULL;

-- enable row level security
ALTER TABLE public.projects ENABLE ROW LEVEL SECURITY;

-- allow authenticated users to SELECT projects they own
CREATE POLICY projects_select_owner ON public.projects
  FOR SELECT
  TO authenticated
  USING ((SELECT auth.uid())::uuid = owner);

-- allow authenticated users to INSERT projects only with owner = auth.uid()
CREATE POLICY projects_insert_owner ON public.projects
  FOR INSERT
  TO authenticated
  WITH CHECK ((SELECT auth.uid())::uuid = owner);

-- allow authenticated users to UPDATE projects they own
CREATE POLICY projects_update_owner ON public.projects
  FOR UPDATE
  TO authenticated
  USING ((SELECT auth.uid())::uuid = owner)
  WITH CHECK ((SELECT auth.uid())::uuid = owner);

-- allow authenticated users to DELETE projects they own
CREATE POLICY projects_delete_owner ON public.projects
  FOR DELETE
  TO authenticated
  USING ((SELECT auth.uid())::uuid = owner);

CREATE TABLE IF NOT EXISTS storage.buckets (
  id text PRIMARY KEY,
  name text,
  owner uuid, -- deprecated in Supabase; keep for compatibility
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  public boolean DEFAULT false,
  avif_autodetection boolean DEFAULT false,
  file_size_limit bigint,
  allowed_mime_types text[],
  owner_id text,
  type storage.buckettype DEFAULT 'STANDARD'::storage.buckettype
);

CREATE TABLE IF NOT EXISTS storage.objects (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  bucket_id text,
  name text,
  owner uuid, -- deprecated
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  last_accessed_at timestamptz NOT NULL DEFAULT now(),
  metadata jsonb,
  path_tokens text[] DEFAULT string_to_array(name, '/'::text),
  version text,
  owner_id text,
  user_metadata jsonb,
  level integer
);

-- foreign key from objects.bucket_id -> buckets.id
ALTER TABLE storage.objects
  ADD CONSTRAINT objects_bucketId_fkey FOREIGN KEY (bucket_id) REFERENCES storage.buckets(id) ON DELETE CASCADE;

-- helper function reference: storage.get_level(name)
-- We'll create a simple stub get_level that returns 0 for compatibility.
CREATE OR REPLACE FUNCTION storage.get_level(text) RETURNS integer LANGUAGE sql STABLE AS $$
  SELECT 0;
$$;

CREATE TABLE IF NOT EXISTS storage.prefixes (
  bucket_id text,
  name text,
  level integer DEFAULT storage.get_level(name),
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now(),
  PRIMARY KEY (bucket_id, name, level)
);

ALTER TABLE storage.prefixes
  ADD CONSTRAINT prefixes_bucketId_fkey FOREIGN KEY (bucket_id) REFERENCES storage.buckets(id) ON DELETE CASCADE;

-- enable RLS
ALTER TABLE storage.buckets ENABLE ROW LEVEL SECURITY;
ALTER TABLE storage.objects ENABLE ROW LEVEL SECURITY;
ALTER TABLE storage.prefixes ENABLE ROW LEVEL SECURITY;

-- Policy: allow authenticated users to read objects in public buckets OR objects that belong to them
CREATE POLICY objects_select_public_or_owner ON storage.objects
  FOR SELECT
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM storage.buckets b
      WHERE b.id = storage.objects.bucket_id
        AND b.public = true
    )
    OR (storage.objects.owner_id IS NOT NULL AND storage.objects.owner_id = (SELECT auth.uid())::text)
  );

-- Policy: allow authenticated users to insert objects only when owner_id = auth.uid()
CREATE POLICY objects_insert_owner ON storage.objects
  FOR INSERT
  TO authenticated
  WITH CHECK (
    (storage.objects.owner_id IS NOT NULL AND storage.objects.owner_id = (SELECT auth.uid())::text)
    OR
    -- service_role or allowed by bucket being public (optional)
    false
  );

-- Policy: allow update/delete only by owner_id matching auth.uid()
CREATE POLICY objects_update_owner ON storage.objects
  FOR UPDATE
  TO authenticated
  USING (storage.objects.owner_id = (SELECT auth.uid())::text)
  WITH CHECK (storage.objects.owner_id = (SELECT auth.uid())::text);

CREATE POLICY objects_delete_owner ON storage.objects
  FOR DELETE
  TO authenticated
  USING (storage.objects.owner_id = (SELECT auth.uid())::text);

-- Buckets: allow SELECT to authenticated only if public = true OR owner_id matches
CREATE POLICY buckets_select_public_or_owner ON storage.buckets
  FOR SELECT
  TO authenticated
  USING (
    public = true OR owner_id = (SELECT auth.uid())::text
  );

-- Buckets: allow INSERT only if owner_id = auth.uid()
CREATE POLICY buckets_insert_owner ON storage.buckets
  FOR INSERT
  TO authenticated
  WITH CHECK (owner_id = (SELECT auth.uid())::text);

-- Prefixes: allow SELECT for objects in public buckets or when owner_id matches
CREATE POLICY prefixes_select_public_or_owner ON storage.prefixes
  FOR SELECT
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM storage.buckets b WHERE b.id = storage.prefixes.bucket_id AND b.public = true
    )
    OR EXISTS (
      SELECT 1 FROM storage.objects o WHERE o.bucket_id = storage.prefixes.bucket_id AND o.owner_id = (SELECT auth.uid())::text
    )
  );